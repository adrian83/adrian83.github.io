---
title: Decorators in Python
date: 2020-05-18
draft: false
categories:
- python
- decorators
tags:
- python
- decorators
---



### Decorators in Python are very powerful and elegant way to wrap functions and classes with custom code. In that code you can modify function arguments, returned values or ever block wrapped function from execution.

#### Introduction

In this post we will see, how to create decorators implemented as functions as well as classes. We will also see, that decorators themselves can have parameters and how multiple decorators behave on a single function.


Before we go to decorators implementations let's see code, that will be used in every example.


```
import types
import time

info_format = "Executing '{0}' with *args: {1} and **kwargs: {2}"

def func_invocation_info(call, *args, **kwargs):
    name = (call if isinstance(call, types.FunctionType) else call.__class__).__name__
    argsStr = ", ".join(args)
    kwargsStr = ", ".join(["{0}={1}".format(k, v) for k, v in kwargs.items()])
    return info_format.format(name, argsStr, kwargsStr)


def introduce(first_name, last_name, **info):
    print("PERSONAL DATA:")
    print("First name: {0}".format(first_name))
    print("Last name: {0}".format(last_name))
    for key, value in info.items():
        print("{0}: {1}".format(key, value))
    print("")
```

First function will be used in every decorator presented below and it will print name of decorated function / class and it's arguments.
Second one is a function, on which we will test every created decorator.


#### I. Python decorators implemented as functions

If you know, what [higher-order functions](https://en.wikipedia.org/wiki/Higher-order_function) and [closures](https://en.wikipedia.org/wiki/Closure_(computer_programming)) are, you will quickly understand, how decorators work. Letâ€™s see simple example.


##### 1. Decorator without it's own parameters
```
def log(func):
    def wrapper(*args, **kwargs):
        print(func_invocation_info(func, *args, **kwargs))
        return func(*args, **kwargs)
    return wrapper


@log
def introduce_ex1(first_name, last_name, **info):
    introduce(first_name, last_name, **info)


introduce_ex1("William", "Shakespeare", Father="John Shakespeare",
            Mother="Mary Arden")
```

Output:
```
Executing 'introduce_ex1' with *args: William, Shakespeare and **kwargs: Father=John Shakespeare, Mother=Mary Arden
PERSONAL DATA:
First name: William
Last name: Shakespeare
Father: John Shakespeare
Mother: Mary Arden
```

The code above can be also written as:
```
introduce_ex1 = log(introduce_ex1)
introduce_ex1("William", "Shakespeare", Father="John Shakespeare",
            Mother="Mary Arden")
```


##### 2. Decorator with it's own parameters
```
def log2(level, file_name):
    def wrapper1(func):
        def wrapper2(*args, **kwargs):
            info = func_invocation_info(func, *args, **kwargs)
            print("[{0}] [{1}] {2}".format(level, file_name, info))
            return func(*args, **kwargs)
        return wrapper2
    return wrapper1


@log2("INFO", "decorator_func.py")
def introduce_ex2(first_name, last_name, **info):
    introduce(first_name, last_name, **info)


introduce_ex2("William", "Shakespeare", Father="John Shakespeare",
            Mother="Mary Arden")
```

Output:
```
[INFO] [decorator_func.py] Executing 'introduce_ex2' with *args: William, Shakespeare and **kwargs: Father=John Shakespeare, Mother=Mary Arden
PERSONAL DATA:
First name: William
Last name: Shakespeare
Father: John Shakespeare
Mother: Mary Arden
```

The code above can be also written as:
```
dec = log2(level, file_name)        #1
introduce_ex2 = dec(introduce_ex2)
introduce_ex2("William", "Shakespeare", Father="John Shakespeare",
            Mother="Mary Arden")
```

Here we can see additional step (#1), which is creation of decorator with two parameters.  


##### 3. Multiple decorators on single function / method

Let's see, what will happen, when we use two decorators defined above on one function. 

```
@log2("INFO", "decorator_func.py")
@log
def introduce_ex3(first_name, last_name, **info):
    introduce(first_name, last_name, **info)
```

Output:
```
[INFO] [decorator_func.py] Executing 'wrapper' with *args: William, Shakespeare and **kwargs: Father=John Shakespeare, Mother=Mary Arden
Executing 'introduce_ex3' with *args: William, Shakespeare and **kwargs: Father=John Shakespeare, Mother=Mary Arden
PERSONAL DATA:
First name: William
Last name: Shakespeare
Father: John Shakespeare
Mother: Mary Arden
```

If you look at the output, you will see that first line generated by @log2 decorator prints *Executing 'wrapper' with...* which means, that @log2 is actually decorating @log decorator. 


#### II. Python decorators implemented as classes

Decorators can be also implemented as classes. Let's see simple example.


##### 1. Decorator without it's own parameters
```
class Log:

    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        print(func_invocation_info(self.func, *args, **kwargs))
        return self.func(*args, **kwargs)


@Log
def introduce_1(first_name, last_name, **info):
    introduce(first_name, last_name, **info)


introduce_1("William", "Shakespeare", Father="John Shakespeare",
            Mother="Mary Arden")
```

Output:
```
Executing 'introduce_ex1' with *args: William, Shakespeare and **kwargs: Father=John Shakespeare, Mother=Mary Arden
PERSONAL DATA:
First name: William
Last name: Shakespeare
Father: John Shakespeare
Mother: Mary Arden
```

As you can see decorator class contains 'magic method' called `__call__`, which allows class instances behave like functions. 
This way both types of decorators are actually very similar.

The code above can be also written as:

```
introduce_ex1 = Log(introduce_ex1)
introduce_ex1("William", "Shakespeare", Father="John Shakespeare",
            Mother="Mary Arden")     # invocation of `__call__` method
```


##### 2. Decorator with it's own parameters

```
class Log2:

    def __init__(self, level, file_name):
        self.level = level
        self.file_name = file_name

    def __call__(self, func):
        def wrapper(*args, **kwargs):
            info = func_invocation_info(func, *args, **kwargs)
            print("[{0}] [{1}] {2}".format(self.level, self.file_name, info))
            return func(*args, **kwargs)
        return wrapper


@Log2("INFO", "decorator_class.py")
def introduce_ex2(first_name, last_name, **info):
    introduce(first_name, last_name, **info)


introduce_ex2("William", "Shakespeare", Father="John Shakespeare",
            Mother="Mary Arden")
```

Output:
```
[INFO] [decorator_class.py] Executing 'introduce_ex2' with *args: William, Shakespeare and **kwargs: Father=John Shakespeare, Mother=Mary Arden
PERSONAL DATA:
First name: William
Last name: Shakespeare
Father: John Shakespeare
Mother: Mary Arden
```

The code above can be also written as:
```
dec = Log2(level, file_name)        #1
introduce_ex2 = dec(introduce_ex2)
introduce_ex2("William", "Shakespeare", Father="John Shakespeare",
            Mother="Mary Arden")
```

Here we can see additional step (#1), which is creation of decorator with two parameters.  


##### 3. Multiple decorators on single function / method
```
@Log2("INFO", "decorator_class.py")
@Log
def introduce_ex3(first_name, last_name, **info):
    introduce(first_name, last_name, **info)


introduce_ex3("William", "Shakespeare", Father="John Shakespeare",
            Mother="Mary Arden")
```

Output:
```
[INFO] [decorator_class.py] Executing 'Log' with *args: William, Shakespeare and **kwargs: Father=John Shakespeare, Mother=Mary Arden
Executing 'introduce_ex3' with *args: William, Shakespeare and **kwargs: Father=John Shakespeare, Mother=Mary Arden
PERSONAL DATA:
First name: William
Last name: Shakespeare
Father: John Shakespeare
Mother: Mary Arden
```

Again, as in the corresponding example above (decorators implemeted as functions) we see, that @Log2 decorator is decorating @Log.


#### Summary 

As you can see, there are no big differences in how both types of decorators work, so you can follow your own preferences. 